// we care about:
// - position
// - velocity
// - new_position
// - time_frame

// new_position has length float3*steps*length
// p = p0 + v*t + 0.5*a*t^2

float factor = 10;

__kernel void compute_movement_path(__global float3* new_position,
                                    __global float* targetDataFlattened, 
                                    __global float* globalData, 
                                    int length, int offset, int steps)
{
    int current_index = get_global_id(0);

    if (current_index < length) {
        float3 position = (float3)(targetDataFlattened[current_index * offset],
                                   targetDataFlattened[current_index * offset + 1],
                                   targetDataFlattened[current_index * offset + 2]);
        float mass = targetDataFlattened[current_index * offset + 3];
        float3 velocity = (float3)(targetDataFlattened[current_index * offset + 4],
                                   targetDataFlattened[current_index * offset + 5],
                                   targetDataFlattened[current_index * offset + 6]);

        for(int step = 0; step < steps; step++){ // Time in Myr, assuming each step is 1 Myr
            float3 acceleration = compute_acceleration(current_index, position, mass, globalData, length, offset);

            float3 displacement = velocity * step + 0.5f * acceleration * (step * step);

            position += displacement;
            velocity += acceleration * step;

            // Store the new position back into the global memory
            new_position[current_index * steps + step] = position;
        }
    }
}
