// For simulations with many bodies, consider more sophisticated 
// algorithms like Barnes-Hut, which reduce computational complexity at the cost of some accuracy.

// we care about:
// - position
// - velocity
// - new_position
// - time_frame

// new_position has length float3*steps*length
// p = p0 + v*t + 0.5*a*t^2

__kernel void compute_movement_path(__global float3* new_position,
                                    __global float* targetDataFlattened, 
                                    __global float* globalData, 
                                    int length, int offset, int steps)
{
    int current_index = get_global_id(0);

    if (current_index < length) {
        float3 position;
        position.x = targetDataFlattened[current_index * offset];
        position.y = targetDataFlattened[current_index * offset + 1];
        position.z = targetDataFlattened[current_index * offset + 2];
        
        float mass = targetDataFlattened[current_index * offset + 3];
        
        float3 velocity;
        velocity.x = targetDataFlattened[current_index * offset + 4];
        velocity.y = targetDataFlattened[current_index * offset + 5];
        velocity.z = targetDataFlattened[current_index * offset + 6];

        for(int step = 0; step < steps; step++){
            float actual_time = (float)step;
            // Compute acceleration at the beginning of each step based on current positions
            float3 acceleration = compute_acceleration(current_index, position, mass, globalData, length, offset);

            float3 displacement = velocity * actual_time + 0.5f * acceleration * (actual_time * actual_time);
            position += displacement;

            velocity += acceleration * actual_time;

            // Store the new position back into the global memory
            new_position[current_index * steps + step] = position;

            targetDataFlattened[current_index * offset] = position.x;
            targetDataFlattened[current_index * offset + 1] = position.y;
            targetDataFlattened[current_index * offset + 2] = position.z;

            targetDataFlattened[current_index * offset + 4] = velocity.x;
            targetDataFlattened[current_index * offset + 5] = velocity.y;
            targetDataFlattened[current_index * offset + 6] = velocity.z;
        }
    }
}